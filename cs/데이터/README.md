# **0과 1로 숫자를 표현하는 방법**

### 정보단위

컴퓨터는 0과 1밖에 이해하지 못한다. 즉 이진수만 이해한다.

- 비트(bit) : 0과 1을 나타내는 가장 작은 정보단위

  - 비트는 이진수의 자리수?
  - 1비트는 2진수로 1의 자리수까지 표현 가능 -> 0b0과 0b1 2^1가지
  - 2비트는 2진수로 2의 자리수까지 표현 가능 -> 0b00 ~ 0b11 2^2가지
  - 3비트는 2진수로 4의 자리수까지 표현 가능 -> 0b000 ~ 0b111 2^3가지
  - 즉, n비트는 2^n가지 정보를 표현할 수 있다.

- 정보단위 변환

|                  |                      |
| :--------------: | :------------------: |
|  1 바이트(byte)  |     8 비트(bit)      |
| 1 킬로바이트(kB) |  1,000 바이트(byte)  |
| 1 메가바이트(MB) | 1,000 킬로바이트(kB) |
| 1 기가바이트(GB) | 1,000 메가바이트(MB) |
| 1 테라바이트(TB) | 1,000 기가바이트(GB) |

> note : 1024 단위로 치환 하는 것은 잘못된 관습이다. 이전 단위를 1024개 묶어 표현한 단위는 KiB, MiB, GiB, TiB로 표현한다.

| 워드(word)                                                                                                                                                                                                                                                                                                                                                                                          |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 중요한 정보 단위 중 **워드**라는 단위가 있다. 워드란 CPU가 한번에 처리할 수 있는 데이터 크기를 의미한다. 만약 CPU가 한 번에 16비트를 처리할 수 있다면 1워드는 16비트가 된다. 이렇게 정의된 워드의 절반 크기를 하프 워드, 1배 크기를 풀 워드, 2배 크기를 더블 워드라고 부른다. 그렇다면 32비트 CPU의 풀 워드는 64비트 CPU의 하프 워드와 같고, 64비트 CPU의 하프워드는 16비트 CPU의 더블 워드와 같다. |

### 이진법

- 코드상에서 이진법을 표현할 때 이진수 앞에 **0b**를 붙인다.
- 컴퓨터는 0과 1밖에 이해할 수 없기 때문에, **2의 보수 표현법**을 사용한다.
- 이진수를 음수로 표현할 때는 **2의 보수(complement)**를 구해 음수로 간주한다.
- 2의 보수의 사전적 의미는 '어떤 수를 그보다 큰 2^n에서 뺀 값'을 의미한다.
- 예를 들어 0b11의 2의 보수는 0b11보다 큰 2^n, 즉 0b100에서 0b11을 뺀 0b01이 된다.
- 2의 보수를 쉽게 표현하는 방법은, 모든 0과 1을 뒤집고 거기에 1을 더한 값으로 이해하면 된다.

| 예시 : 0b1011을 음수로 표현하기 |        |
| :------------------------------ | :----- |
| 모든 0과 1 뒤집기               | 0100   |
| 1 더하기                        | 0101   |
| 0b1011을 음수로 표현한 값       | 0b0101 |

- 그런데 -1011을 표현하기 위한 음수로서의 0101과 십진수 5를 표현하기 위한 양수로서의 0101은 똑같이 생겼기 때문에 이것만으로는 컴퓨터가 부호를 구분할 수 없다. 따라서 컴퓨터 내부에서는 어떤 수를 다룰때는 양수인지 음수인지를 구분하기 위해 **플래그**를 사용한다.

- 2의 보수 표현에도 한계가 있다. 0이나 2^n 형태의 이진수에 2의 보수를 취하면 원하는 음수 값을 얻을 수 없다.

  - 0 : 4bit를 가정하고, 0을 음수로 표현하면 0b10000이다. 하지만 자리 올림이 발생한 비트의 1을 버리기 때문에 2의 보수 표현으로는 0이 한 가지만 존재하므로 2의 보수 표현에서 0은 -0, +0 두 가지가 아닌 한 가지만 존재하게 된다.(이러한 이유로 2의 보수 표현법을 쓴다고 한다.)
  - 2^n : 하지만, 2^n의 보수를 취하면 자기 자신이 되어버리는 문제가 발생한다. 2^3(0b1000)을 음수로 표현하면 자기 자신이 된다.(1000 -> 0111 -> 0111 + 1 = 1000) 즉, n비트로는 -2^n과 2^n을 동시에 표현할 수 없다. 0과는 반대의 문제가 생기는 것이다.

|                                            예제 : 8 - 6                                            |             |
| :------------------------------------------------------------------------------------------------: | :---------: |
|                                               10진수                                               |    8 - 6    |
|                                             2진수 변환                                             | 1000 - 0110 |
|                                         2의 보수 표현 반영                                         | 1000 + 1010 |
|                                          2진수 덧셈 결과                                           |    10010    |
| 제일 왼쪽 비트에서 자리 올림이 발생한 경우는 계산한 답이 양수라는 뜻이다. <br>올림 자리수를 없앤다 |    0010     |
|                                               10진수                                               |      2      |

|                                     예제 : 6 - 8                                      |             |
| :-----------------------------------------------------------------------------------: | :---------: |
|                                        10진수                                         |    6 - 8    |
|                                      2진수 변환                                       | 0110 - 1000 |
|                                  2의 보수 표현 반영                                   | 0110 + 1000 |
|                                    2진수 덧셈 결과                                    |    1110     |
| 자리올림이 발생하지 않았다면 계산한 답이 음수라는 뜻이다.<br>2의 보수 표현으로 바꾼다 |    0010     |
|                                        10진수                                         |     -2      |

### 십육진법

- 십육진수는 숫자 앞에 **0x**를 붙여 구분한다.
- 십육진수는 한 글자로 열여섯 종류(0~9, A\~F)의 정보를 표현할 수 있다.
- 십육진법을 사용하는 주된 이유 중 하나는 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉽기 때문이다.
- 십육진수를 이진수로 변환하는 간편한 방법 중 하나는 십육진수 한 글자를 4비트의 이진수로 간주하는 것이다.
  - 십육진수 숫자 하나를 이진수로 표현하려면 4비트가 필요하기 때문이다.

| 예제 : 0x1A2B을 이진수로 변환 |                        |
| :---------------------------: | :--------------------: |
|              0x1              |         0b0001         |
|              0xA              |         0b1010         |
|              0x2              |         0b0010         |
|              0xB              |         0b1011         |
|            0x1A2B             | 0b*0001*1010*0010*1011 |

| 예제 : 0b11010101을 십육진수로 변환 |        |
| :---------------------------------: | :----: |
|               0b1101                |  0xD   |
|               0b0101                |  0x5   |
|             0b11010101              | 0xD*5* |

# **0과 1로 문자를 표현하는 방법**

### 문자 집합과 인코딩

- 문자집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 인코딩 : 문자집합에 속한 문자를 0과 1로 변환하는 과정. 그 결과 값이 문자 코드가 된다.
- 디코딩 : 인코딩의 반대. 즉, 0과 1로 이루어진 문자 코드를 문자로 변환하는 과정.

### 아스키 코드(ASCII : American Standard Code for Information Interchange)

- 아스키 문자 집합에 속한 문자들은 각각 7비트로 표현되는데, 7비트로 표현할 수 있는 정보의 가짓수는 2^7개로, 총 128개의 문자를 표현할 수 있다.
- 실제로는 하나의 아스키 문자를 나타내기 위해 1바이트를 사용한다. 하지만 그 중 1비트는 패리티 비트(parity bit)라고 불리는 오류검출을 위해 사용되는 비트이기 때문에 실질적으로 문자 표현을 위해 사용되는 비트는 7비트라고 한다.
- 코드 포인트 : 문자 인코딩에서 '글자에 부여된 고유한 값'을 코드포인트라고 한다. 가령, 아스키 문자 A의 코드포인트는 65(10진수)이다.
- 약어의 의미 그대로 미국 표준이다. 그래서 한글을 표현하지 못한다.

### EUC-KR

- 한글을 0과 1로 표현할 수 있는 고유한 문자 집합과 인코딩 방식이 필요하다고 느껴 만들어진 인코딩 방식.
- 한글 인코딩에는 **완성형과 조합형**이 존재하는데, EUC-KR은 완성형 인코딩 방식이다.
- EUC-KR로 인코딩된 한글 한 글자를 표현하려면 16비트가 필요하다. 그리고 16비트는 네 자리 십육진수로 표현 가능하다. 즉, EUC-KR로 인코딩된 한글은 네 자리 십육진수로 나타낼 수 있다.
- EUC-KR 인코딩 방식은 총 2,350개의 한글을 표현할 수 있지만 모든 한글 조합을 표현할 수 없었다.
- 이러한 문제를 해결 하기 위해 마이크로소프트의 CP949(Code Page 949)인데, 이 또한 한글 전체를 표현할 수 없었다.

### 유니코드와 UTF-8

- 다국어를 지원하는 프로그램을 만들 때 각 나라 언어의 인코딩을 모두 알아야하는 번거로움이 있다. 그런데 만약, 모든 나라 언어의 문자 집합과 인코딩 방식이 통일되어 있다면 언어별로 인코딩하는 수고로움을 덜 수 있다.
- 그래서 **유니코드**가 등장했다.
- 유니코드는 대부분 나라의 문자, 특수문자, 화살표나 이모티콘까지도 코드로 표현할 수 있는 통일된 문자집합이다.
- 앞의 아스키코드, EUC-KR는 코드포인트가 인코딩 값이었다면, 유니코드는 코드포인트를 다양한 방법으로 인코딩한다.
- 이러한 인코딩 방법에는 크게 UTF-8, UTF-16, UTF-32 등이 있다.

> 출처 \
> \- [혼자 공부하는 컴퓨터 구조 + 운영체제](https://product.kyobobook.co.kr/detail/S000061584886) \
> \- [인프런 저자 직강](https://inf.run/M23e)
